{"mappings":"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","sources":["<anon>","src/main.ts","src/shaders/core.ts","src/shaders/compute.ts","src/pipelines/core.ts","src/pipelines/compute.ts","src/buffers/uniform.ts","src/utils/createInputArray.ts","src/buffers/workBuffer.ts","src/buffers/readBuffer.ts","src/bindGroups/computeBindGroup.ts","src/bindGroups/renderBindGroup.ts","src/utils/update.ts"],"sourcesContent":["(function () {\nconst $4dd4b039a1bfcf81$export$c2d11d8491bba673 = {\n    vertex: `\n        struct Particle {\n            pos : vec2<f32>,\n            vel : vec2<f32>,\n            radius : vec4<f32>,\n        }   \n\n        @group(0) @binding(0) var<storage, read> data: array<Particle>;\n\n        struct VertexOutput {\n            @builtin(position) Position : vec4<f32>,\n            @location(0) color : vec3<f32>          \n        }      \n\n        @vertex\n        fn vertex_main(\n            @builtin(vertex_index) VertexIndex : u32 ,\n            @builtin(instance_index) InstanceIndex : u32,\n        ) -> VertexOutput {\n       \n            let scale:f32 = data[InstanceIndex].radius[0];\n            let a:f32 = 1.0 * scale;\n            let b:f32 = 0.71 * scale;  \n            let c:f32 = 0.923 * scale;  \n            let d:f32 = 0.382 * scale;  \n    \n            var pos = array<vec2<f32>, 6*4*2> (\n                vec2( 0.0,  0.0), vec2( a, 0.0), vec2(c, d),\n                vec2( 0.0,  0.0), vec2(c, d), vec2(b,  b),\n                \n                vec2( 0.0,  0.0), vec2(b,  b), vec2(d,  c),\n                vec2( 0.0,  0.0), vec2(d,  c), vec2(0.0,  a),\n                \n                vec2( 0.0,  0.0), vec2( 0.0, a), vec2(-d, c),\n                vec2( 0.0,  0.0), vec2(-d, c), vec2(-b, b),\n                \n                vec2( 0.0,  0.0), vec2(-b, b), vec2(-c, d),\n                vec2( 0.0,  0.0), vec2(-c, d), vec2(-a,  0.0),\n                \n                \n                vec2( 0.0,  0.0), vec2( -a, 0.0), vec2(-c, -d),\n                vec2( 0.0,  0.0), vec2(-c, -d), vec2(-b, -b),\n                \n                vec2( 0.0,  0.0), vec2(-b, -b), vec2(-d, -c),\n                vec2( 0.0,  0.0), vec2(-d, -c), vec2(0.0, -a),\n                \n                vec2( 0.0,  0.0), vec2(0.0, -a), vec2(d, -c),\n                vec2( 0.0,  0.0), vec2(d, -c), vec2(b, -b),\n                \n                vec2( 0.0,  0.0), vec2(b, -b), vec2(c, -d),\n                vec2( 0.0,  0.0), vec2(c, -d), vec2(a, 0.0),\n            );\n    \n            let lengthVelInstance = length(data[InstanceIndex].vel) * 10.0;\n            \n            var output : VertexOutput;\n            output.Position = vec4<f32>(\n                pos[VertexIndex].x + data[InstanceIndex].pos[0], //x\n                pos[VertexIndex].y + data[InstanceIndex].pos[1], //y\n                0.0, //z\n                1.0 //w\n            );\n            \n            output.color = vec3(\n                lengthVelInstance + data[InstanceIndex].radius[1], \n                data[InstanceIndex].radius[2],  \n                1.0 - lengthVelInstance\n            ) + data[InstanceIndex].radius[3];\n    \n            return output;\n        }`,\n    fragment: `\n            @fragment\n            fn fragment_main(@location(0) color: vec3<f32>) -> @location(0) vec4<f32> {\n            return vec4<f32>(color,1.0);\n        }`\n};\n\n\nconst $54feda086f81ce87$export$3f0b4aed70ce6e01 = (device)=>device.createShaderModule({\n        label: \"compute module\",\n        code: `\n        struct Particle {\n            pos : vec2<f32>,\n            vel : vec2<f32>,\n            radius : vec4<f32>,\n        }\n        \n        struct Particles {\n            particles : array<Particle>,\n        }\n        \n        struct Uniforms {\n            deltaTime : f32\n        }\n        \n        @group(0) @binding(0) var<storage, read> particlesA: Particles;\n        @group(0) @binding(1) var<storage, read_write> particlesB: Particles;\n        @group(0) @binding(2) var<uniform> uniforms : Uniforms;\n        \n        @compute @workgroup_size(64) fn computeBoundaries(\n            @builtin(global_invocation_id) id: vec3<u32>\n        ) {\n        \n            if (id.x >= u32(arrayLength(&particlesA.particles))) {\n               return;\n            }\n            \n            let index = id.x;\n            var vPos = particlesA.particles[index].pos;\n            var vVel = particlesA.particles[index].vel;\n            \n            let friction : f32 = 0.99;\n            var newPos = vPos + vVel * uniforms.deltaTime;\n            var newVel = vVel * friction;\n            \n            let circleRadius : f32 =  particlesA.particles[index].radius[0];\n            let gravity : vec2<f32> =  vec2<f32>(0.0, - 0.001);\n            \n            if(newPos.x > (1.0 - circleRadius)){\n               newVel.x = -vVel.x;\n               newPos = vPos + newVel;\n            }\n            \n            if(newPos.x < (-1.0 + circleRadius)){\n               newVel.x = -vVel.x; \n               newPos = vPos + newVel;\n            }\n            \n            if(newPos.y > (1.0 - circleRadius)){\n               newVel.y = -vVel.y;\n               newPos = vPos + newVel;\n            }\n            \n            if(newPos.y < (-1.0 + circleRadius)){\n               newVel.y = vVel.y * -0.9;\n               newPos = vPos + newVel;\n               \n               if(length(newVel) < circleRadius  ){\n                 newPos.y = -1.0 + circleRadius;\n               }                   \n            }\n                                        \n            particlesB.particles[index].pos = newPos;  \n            particlesB.particles[index].vel = newVel + gravity; \n            particlesB.particles[index].radius = particlesA.particles[index].radius;                            \n        }\n    `\n    });\n\n\nconst $37f4d69c861b76d6$export$24834c1001b698b9 = (device, coreShader, format)=>device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n            module: device.createShaderModule({\n                code: coreShader.vertex\n            }),\n            entryPoint: \"vertex_main\"\n        },\n        fragment: {\n            module: device.createShaderModule({\n                code: coreShader.fragment\n            }),\n            entryPoint: \"fragment_main\",\n            targets: [\n                {\n                    format: format\n                }\n            ]\n        },\n        primitive: {\n            topology: \"triangle-list\"\n        }\n    });\n\n\nconst $c0b68bd0800d686e$export$25b15a8d8560372a = (device, computeModule)=>device.createComputePipeline({\n        label: \"compute pipeline\",\n        layout: \"auto\",\n        compute: {\n            module: computeModule,\n            entryPoint: \"computeBoundaries\"\n        }\n    });\n\n\nconst $76c6afc1fa08f41e$export$fc8798681fa35e65 = (device, inputTime)=>device.createBuffer({\n        label: \"buffer Position\",\n        size: inputTime.byteLength,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n    });\n\n\nconst $762fa2c56d144a09$export$c91d4f020e1b5dff = (particleAmount)=>{\n    const input = new Float32Array(particleAmount * 8);\n    for(let i = 0; i < particleAmount; ++i){\n        input[8 * i] = 2 * (Math.random() - 0.5) * 0.9 //position X\n        ;\n        input[8 * i + 1] = 2 * (Math.random() - 0.5) * 0.9 //position Y\n        ;\n        input[8 * i + 2] = 2 * (Math.random() - 0.5) * 0.3 //velocity X\n        ;\n        input[8 * i + 3] = 2 * (Math.random() - 0.5) * 0.3 //velocity Y\n        ;\n        input[8 * i + 4] = 0.01 //scale\n        ;\n        input[8 * i + 5] = Math.random() * 0.3;\n        input[8 * i + 6] = Math.random() * 0.7;\n        input[8 * i + 7] = Math.random() * 0.3;\n    }\n    return input;\n};\n\n\nconst $4c8d0c48b0c47d09$export$e5164f1fb56eb00 = (device, size)=>device.createBuffer({\n        label: \"work buffer\",\n        size: size,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST\n    });\n\n\nconst $50b5fea2df745348$export$ca4ceb6a6f5a924 = (device, size)=>device.createBuffer({\n        label: \"result buffer\",\n        size: size,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n    });\n\n\nconst $6f12acf4fe0b2f8f$export$5854928c832c8909 = (device, computePipeline, buffer1, buffer2, uniformBuffer)=>device.createBindGroup({\n        layout: computePipeline.getBindGroupLayout(0),\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: buffer1\n                }\n            },\n            {\n                binding: 1,\n                resource: {\n                    buffer: buffer2\n                }\n            },\n            {\n                binding: 2,\n                resource: {\n                    buffer: uniformBuffer\n                }\n            }\n        ]\n    });\n\n\nconst $4ca97dad8fb5626f$export$160e2ecb0ad6cf93 = (device, pipeline, buffer)=>device.createBindGroup({\n        layout: pipeline.getBindGroupLayout(0),\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: buffer\n                }\n            }\n        ]\n    });\n\n\nlet $634d558692add223$var$lastTime = 0;\nlet $634d558692add223$var$time = 0;\nconst $634d558692add223$export$722fbec263ad908a = async (device, uniformBuffer, computePipeline, data, particleAmount, readBuffer, context, pipeline)=>{\n    const deltaTime = $634d558692add223$var$time - $634d558692add223$var$lastTime;\n    $634d558692add223$var$lastTime = $634d558692add223$var$time;\n    device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([\n        deltaTime * 0.05\n    ]));\n    const encoder = device.createCommandEncoder({\n        label: \"doubling encoder\"\n    });\n    const computePass = encoder.beginComputePass({\n        label: \"doubling compute pass\"\n    });\n    computePass.setPipeline(computePipeline);\n    computePass.setBindGroup(0, data[$634d558692add223$var$time % 2].bindGroup);\n    computePass.dispatchWorkgroups(Math.ceil(particleAmount / 64));\n    computePass.end();\n    encoder.copyBufferToBuffer(data[$634d558692add223$var$time % 2].buffer, 0, readBuffer, 0, readBuffer.size);\n    device.queue.submit([\n        encoder.finish()\n    ]);\n    // Read the results\n    await readBuffer.mapAsync(GPUMapMode.READ);\n    readBuffer.unmap();\n    const encoderRender = device.createCommandEncoder({\n        label: \"doubling encoder\"\n    });\n    const textureView = context.getCurrentTexture().createView() // тектура к которой привязан контекст\n    ;\n    const renderPass = encoderRender.beginRenderPass({\n        colorAttachments: [\n            {\n                view: textureView,\n                clearValue: {\n                    r: 0.5,\n                    g: 0.5,\n                    b: 0.5,\n                    a: 1.0\n                },\n                loadOp: \"clear\",\n                storeOp: \"store\"\n            }\n        ]\n    });\n    renderPass.setPipeline(pipeline);\n    renderPass.setBindGroup(0, data[$634d558692add223$var$time % 2].bindGroupRender);\n    renderPass.draw(64, particleAmount);\n    renderPass.end();\n    device.queue.submit([\n        encoderRender.finish()\n    ]);\n    ++$634d558692add223$var$time;\n    window.requestAnimationFrame(()=>$634d558692add223$export$722fbec263ad908a(device, uniformBuffer, computePipeline, data, particleAmount, readBuffer, context, pipeline));\n};\n\n\nconst $205b16af4c42845f$var$init = async ()=>{\n    if (!navigator.gpu) {\n        alert(\"Your browser does not support WebGPU :(\");\n        return;\n    }\n    const PARTICLE_AMOUNT = 100000;\n    const canvas = document.querySelector(\"#canvas\");\n    const context = canvas.getContext(\"webgpu\");\n    const adapter = await navigator.gpu.requestAdapter();\n    if (!adapter) {\n        alert(\"Your browser blocks access to physical gpu :(\");\n        return;\n    }\n    const device = await adapter.requestDevice();\n    const format = navigator.gpu.getPreferredCanvasFormat() // формат данных в которых храняться пиксели в физическом устройстве\n    ;\n    context.configure({\n        device: device,\n        format: format,\n        alphaMode: \"opaque\"\n    });\n    const computeModule = (0, $54feda086f81ce87$export$3f0b4aed70ce6e01)(device);\n    const pipeline = (0, $37f4d69c861b76d6$export$24834c1001b698b9)(device, (0, $4dd4b039a1bfcf81$export$c2d11d8491bba673), format);\n    const computePipeline = (0, $c0b68bd0800d686e$export$25b15a8d8560372a)(device, computeModule);\n    const inputTime = new Float32Array([\n        1.0\n    ]);\n    const input = (0, $762fa2c56d144a09$export$c91d4f020e1b5dff)(PARTICLE_AMOUNT);\n    const uniformBuffer = (0, $76c6afc1fa08f41e$export$fc8798681fa35e65)(device, inputTime);\n    const workBufferA = (0, $4c8d0c48b0c47d09$export$e5164f1fb56eb00)(device, input.byteLength);\n    const workBufferB = (0, $4c8d0c48b0c47d09$export$e5164f1fb56eb00)(device, input.byteLength);\n    const readBuffer = (0, $50b5fea2df745348$export$ca4ceb6a6f5a924)(device, input.byteLength);\n    device.queue.writeBuffer(uniformBuffer, 0, inputTime);\n    device.queue.writeBuffer(workBufferA, 0, input);\n    device.queue.writeBuffer(workBufferB, 0, input);\n    const data = [\n        {\n            bindGroup: (0, $6f12acf4fe0b2f8f$export$5854928c832c8909)(device, computePipeline, workBufferA, workBufferB, uniformBuffer),\n            buffer: workBufferA,\n            bindGroupRender: (0, $4ca97dad8fb5626f$export$160e2ecb0ad6cf93)(device, pipeline, workBufferA)\n        },\n        {\n            bindGroup: (0, $6f12acf4fe0b2f8f$export$5854928c832c8909)(device, computePipeline, workBufferB, workBufferA, uniformBuffer),\n            buffer: workBufferB,\n            bindGroupRender: (0, $4ca97dad8fb5626f$export$160e2ecb0ad6cf93)(device, pipeline, workBufferB)\n        }\n    ];\n    (0, $634d558692add223$export$722fbec263ad908a)(device, uniformBuffer, computePipeline, data, PARTICLE_AMOUNT, readBuffer, context, pipeline);\n};\n$205b16af4c42845f$var$init();\n\n})();\n//# sourceMappingURL=index.5e55d995.js.map\n","import { coreShader } from './shaders/core'\nimport { getComputeShader } from './shaders/compute'\nimport { createCorePipeline } from './pipelines/core'\nimport { createComputePipeline } from './pipelines/compute'\nimport { createUniformBuffer } from './buffers/uniform'\nimport { createInputArray } from './utils/createInputArray'\nimport { createWorkBuffer } from './buffers/workBuffer'\nimport { createReadBuffer } from './buffers/readBuffer'\nimport { createComputeBindGroup } from './bindGroups/computeBindGroup'\nimport { createRenderBindGroup } from './bindGroups/renderBindGroup'\nimport { update } from './utils/update'\n\nconst init = async () => {\n\n    if (!navigator.gpu) {\n        alert('Your browser does not support WebGPU :(')\n        return\n    }\n\n    const PARTICLE_AMOUNT = 100000\n    const canvas = document.querySelector('#canvas') as HTMLCanvasElement\n    const context = canvas.getContext('webgpu') as GPUCanvasContext\n    const adapter = await navigator.gpu.requestAdapter()\n\n    if (!adapter) {\n        alert('Your browser blocks access to physical gpu :(')\n        return\n    }\n\n    const device = await adapter.requestDevice()\n    const format = navigator.gpu.getPreferredCanvasFormat() // формат данных в которых храняться пиксели в физическом устройстве\n\n    context.configure({\n        device: device,\n        format: format,\n        alphaMode: 'opaque',\n    })\n\n    const computeModule = getComputeShader(device)\n    const pipeline = createCorePipeline(device, coreShader, format)\n    const computePipeline = createComputePipeline(device, computeModule)\n\n    const inputTime = new Float32Array([ 1.0 ])\n    const input = createInputArray(PARTICLE_AMOUNT)\n\n    const uniformBuffer = createUniformBuffer(device, inputTime)\n    const workBufferA = createWorkBuffer(device, input.byteLength)\n    const workBufferB = createWorkBuffer(device, input.byteLength)\n    const readBuffer = createReadBuffer(device, input.byteLength)\n\n    device.queue.writeBuffer(uniformBuffer, 0, inputTime)\n    device.queue.writeBuffer(workBufferA, 0, input)\n    device.queue.writeBuffer(workBufferB, 0, input)\n\n    const data = [\n        {\n            bindGroup: createComputeBindGroup(device, computePipeline, workBufferA, workBufferB, uniformBuffer),\n            buffer: workBufferA,\n            bindGroupRender: createRenderBindGroup(device, pipeline, workBufferA)\n        },\n        {\n            bindGroup: createComputeBindGroup(device, computePipeline, workBufferB, workBufferA, uniformBuffer),\n            buffer: workBufferB,\n            bindGroupRender: createRenderBindGroup(device, pipeline, workBufferB)\n        } ]\n\n    update(device, uniformBuffer, computePipeline, data, PARTICLE_AMOUNT, readBuffer, context, pipeline)\n}\n\ninit()\n","export const coreShader = {\n    vertex: `\n        struct Particle {\n            pos : vec2<f32>,\n            vel : vec2<f32>,\n            radius : vec4<f32>,\n        }   \n\n        @group(0) @binding(0) var<storage, read> data: array<Particle>;\n\n        struct VertexOutput {\n            @builtin(position) Position : vec4<f32>,\n            @location(0) color : vec3<f32>          \n        }      \n\n        @vertex\n        fn vertex_main(\n            @builtin(vertex_index) VertexIndex : u32 ,\n            @builtin(instance_index) InstanceIndex : u32,\n        ) -> VertexOutput {\n       \n            let scale:f32 = data[InstanceIndex].radius[0];\n            let a:f32 = 1.0 * scale;\n            let b:f32 = 0.71 * scale;  \n            let c:f32 = 0.923 * scale;  \n            let d:f32 = 0.382 * scale;  \n    \n            var pos = array<vec2<f32>, 6*4*2> (\n                vec2( 0.0,  0.0), vec2( a, 0.0), vec2(c, d),\n                vec2( 0.0,  0.0), vec2(c, d), vec2(b,  b),\n                \n                vec2( 0.0,  0.0), vec2(b,  b), vec2(d,  c),\n                vec2( 0.0,  0.0), vec2(d,  c), vec2(0.0,  a),\n                \n                vec2( 0.0,  0.0), vec2( 0.0, a), vec2(-d, c),\n                vec2( 0.0,  0.0), vec2(-d, c), vec2(-b, b),\n                \n                vec2( 0.0,  0.0), vec2(-b, b), vec2(-c, d),\n                vec2( 0.0,  0.0), vec2(-c, d), vec2(-a,  0.0),\n                \n                \n                vec2( 0.0,  0.0), vec2( -a, 0.0), vec2(-c, -d),\n                vec2( 0.0,  0.0), vec2(-c, -d), vec2(-b, -b),\n                \n                vec2( 0.0,  0.0), vec2(-b, -b), vec2(-d, -c),\n                vec2( 0.0,  0.0), vec2(-d, -c), vec2(0.0, -a),\n                \n                vec2( 0.0,  0.0), vec2(0.0, -a), vec2(d, -c),\n                vec2( 0.0,  0.0), vec2(d, -c), vec2(b, -b),\n                \n                vec2( 0.0,  0.0), vec2(b, -b), vec2(c, -d),\n                vec2( 0.0,  0.0), vec2(c, -d), vec2(a, 0.0),\n            );\n    \n            let lengthVelInstance = length(data[InstanceIndex].vel) * 10.0;\n            \n            var output : VertexOutput;\n            output.Position = vec4<f32>(\n                pos[VertexIndex].x + data[InstanceIndex].pos[0], //x\n                pos[VertexIndex].y + data[InstanceIndex].pos[1], //y\n                0.0, //z\n                1.0 //w\n            );\n            \n            output.color = vec3(\n                lengthVelInstance + data[InstanceIndex].radius[1], \n                data[InstanceIndex].radius[2],  \n                1.0 - lengthVelInstance\n            ) + data[InstanceIndex].radius[3];\n    \n            return output;\n        }`,\n\n    fragment: `\n            @fragment\n            fn fragment_main(@location(0) color: vec3<f32>) -> @location(0) vec4<f32> {\n            return vec4<f32>(color,1.0);\n        }`\n}\n","export const getComputeShader = (device: GPUDevice) => device.createShaderModule({\n    label: 'compute module',\n    code: `\n        struct Particle {\n            pos : vec2<f32>,\n            vel : vec2<f32>,\n            radius : vec4<f32>,\n        }\n        \n        struct Particles {\n            particles : array<Particle>,\n        }\n        \n        struct Uniforms {\n            deltaTime : f32\n        }\n        \n        @group(0) @binding(0) var<storage, read> particlesA: Particles;\n        @group(0) @binding(1) var<storage, read_write> particlesB: Particles;\n        @group(0) @binding(2) var<uniform> uniforms : Uniforms;\n        \n        @compute @workgroup_size(64) fn computeBoundaries(\n            @builtin(global_invocation_id) id: vec3<u32>\n        ) {\n        \n            if (id.x >= u32(arrayLength(&particlesA.particles))) {\n               return;\n            }\n            \n            let index = id.x;\n            var vPos = particlesA.particles[index].pos;\n            var vVel = particlesA.particles[index].vel;\n            \n            let friction : f32 = 0.99;\n            var newPos = vPos + vVel * uniforms.deltaTime;\n            var newVel = vVel * friction;\n            \n            let circleRadius : f32 =  particlesA.particles[index].radius[0];\n            let gravity : vec2<f32> =  vec2<f32>(0.0, - 0.001);\n            \n            if(newPos.x > (1.0 - circleRadius)){\n               newVel.x = -vVel.x;\n               newPos = vPos + newVel;\n            }\n            \n            if(newPos.x < (-1.0 + circleRadius)){\n               newVel.x = -vVel.x; \n               newPos = vPos + newVel;\n            }\n            \n            if(newPos.y > (1.0 - circleRadius)){\n               newVel.y = -vVel.y;\n               newPos = vPos + newVel;\n            }\n            \n            if(newPos.y < (-1.0 + circleRadius)){\n               newVel.y = vVel.y * -0.9;\n               newPos = vPos + newVel;\n               \n               if(length(newVel) < circleRadius  ){\n                 newPos.y = -1.0 + circleRadius;\n               }                   \n            }\n                                        \n            particlesB.particles[index].pos = newPos;  \n            particlesB.particles[index].vel = newVel + gravity; \n            particlesB.particles[index].radius = particlesA.particles[index].radius;                            \n        }\n    `,\n})\n","export const createCorePipeline = (\n    device: GPUDevice,\n    coreShader: { vertex: string, fragment: string },\n    format: GPUTextureFormat\n) =>\n    device.createRenderPipeline({\n        layout: 'auto',\n        vertex: {\n            module: device.createShaderModule({\n                code: coreShader.vertex\n            }),\n            entryPoint: 'vertex_main'\n        },\n        fragment: {\n            module: device.createShaderModule({\n                code: coreShader.fragment\n            }),\n            entryPoint: 'fragment_main',\n            targets: [ {\n                format: format\n            } ]\n        },\n        primitive: {\n            topology: 'triangle-list',\n        }\n    })\n","export const createComputePipeline = (device: GPUDevice, computeModule: GPUShaderModule) =>\n    device.createComputePipeline({\n        label: 'compute pipeline',\n        layout: 'auto',\n        compute: {\n            module: computeModule,\n            entryPoint: 'computeBoundaries',\n        },\n    })\n","export const createUniformBuffer = (device: GPUDevice, inputTime: Float32Array) => device.createBuffer({\n    label: 'buffer Position',\n    size: inputTime.byteLength,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n})\n","export const createInputArray = (particleAmount: number) => {\n    const input = new Float32Array(particleAmount * 8)\n    for (let i = 0; i < particleAmount; ++i) {\n        input[8 * i    ] = 2 * (Math.random() - 0.5) * 0.9 //position X\n        input[8 * i + 1] = 2 * (Math.random() - 0.5) * 0.9 //position Y\n\n        input[8 * i + 2] = 2 * (Math.random() - 0.5) * 0.3 //velocity X\n        input[8 * i + 3] = 2 * (Math.random() - 0.5) * 0.3 //velocity Y\n\n        input[8 * i + 4] = 0.01 //scale\n        input[8 * i + 5] = Math.random() * 0.3\n        input[8 * i + 6] = Math.random() * 0.7\n        input[8 * i + 7] = Math.random() * 0.3\n    }\n\n    return input\n}\n","export const createWorkBuffer = (device: GPUDevice, size: GPUSize64) => device.createBuffer({\n    label: 'work buffer',\n    size,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n})\n","export const createReadBuffer = (device: GPUDevice, size: GPUSize64) => device.createBuffer({\n    label: 'result buffer',\n    size,\n    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n})\n","export const createComputeBindGroup = (\n    device: GPUDevice,\n    computePipeline: GPUComputePipeline,\n    buffer1: GPUBuffer,\n    buffer2: GPUBuffer,\n    uniformBuffer: GPUBuffer\n) =>\n    device.createBindGroup({\n        layout: computePipeline.getBindGroupLayout(0),\n        entries: [\n            {\n                binding: 0,\n                resource: {\n                    buffer: buffer1\n                }\n            },\n            {\n                binding: 1,\n                resource: {\n                    buffer: buffer2\n                }\n            },\n            {\n                binding: 2,\n                resource: {\n                    buffer: uniformBuffer\n                }\n            },\n        ],\n    })\n","export const createRenderBindGroup = (device: GPUDevice, pipeline: GPURenderPipeline, buffer: GPUBuffer) => device.createBindGroup({\n    layout: pipeline.getBindGroupLayout(0),\n    entries: [\n        {\n            binding: 0,\n            resource: {\n                buffer \n            }\n        },\n    ],\n})\n","let lastTime = 0\nlet time = 0\n\nexport const update = async (\n    device: GPUDevice,\n    uniformBuffer: GPUBuffer,\n    computePipeline: GPUComputePipeline,\n    data: { bindGroupRender: GPUBindGroup, buffer: GPUBuffer, bindGroup: GPUBindGroup }[],\n    particleAmount: number,\n    readBuffer: GPUBuffer,\n    context: GPUCanvasContext,\n    pipeline: GPURenderPipeline\n) => {\n    const deltaTime = time - lastTime\n    lastTime = time\n\n    device.queue.writeBuffer(uniformBuffer, 0, new Float32Array([ deltaTime * 0.05 ]))\n\n    const encoder = device.createCommandEncoder({\n        label: 'doubling encoder',\n    })\n\n    const computePass = encoder.beginComputePass({\n        label: 'doubling compute pass',\n    })\n\n    computePass.setPipeline(computePipeline)\n    computePass.setBindGroup(0, data[time % 2].bindGroup)\n    computePass.dispatchWorkgroups(Math.ceil(particleAmount / 64))\n    computePass.end()\n\n    encoder.copyBufferToBuffer(data[time % 2].buffer, 0, readBuffer, 0, readBuffer.size)\n\n    device.queue.submit([ encoder.finish() ])\n\n    // Read the results\n    await readBuffer.mapAsync(GPUMapMode.READ)\n    readBuffer.unmap()\n\n    const encoderRender = device.createCommandEncoder({\n        label: 'doubling encoder',\n    })\n\n    const textureView = context.getCurrentTexture().createView() // тектура к которой привязан контекст\n    const renderPass = encoderRender.beginRenderPass({  // натсраиваем проход рендера, подключаем текстуру канваса это значать выводлить результат на канвас\n        colorAttachments: [ {\n            view: textureView,\n            clearValue: {\n                r: 0.5,\n                g: 0.5,\n                b: 0.5,\n                a: 1.0\n            },\n            loadOp: 'clear',\n            storeOp: 'store'\n        } ]\n    })\n    renderPass.setPipeline(pipeline)\n    renderPass.setBindGroup(0, data[time % 2].bindGroupRender)\n    renderPass.draw(64, particleAmount)\n    renderPass.end()\n\n    device.queue.submit([ encoderRender.finish() ])\n    ++time\n    window.requestAnimationFrame(() => update(device, uniformBuffer, computePipeline, data, particleAmount, readBuffer, context, pipeline))\n}\n"],"names":["$4dd4b039a1bfcf81$export$c2d11d8491bba673","vertex","fragment","$54feda086f81ce87$export$3f0b4aed70ce6e01","device","createShaderModule","label","code","$37f4d69c861b76d6$export$24834c1001b698b9","coreShader","format","createRenderPipeline","layout","module","entryPoint","targets","primitive","topology","$c0b68bd0800d686e$export$25b15a8d8560372a","computeModule","createComputePipeline","compute","$76c6afc1fa08f41e$export$fc8798681fa35e65","inputTime","createBuffer","size","byteLength","usage","GPUBufferUsage","UNIFORM","COPY_DST","$762fa2c56d144a09$export$c91d4f020e1b5dff","particleAmount","input","Float32Array","i","Math","random","$4c8d0c48b0c47d09$export$e5164f1fb56eb00","STORAGE","COPY_SRC","$50b5fea2df745348$export$ca4ceb6a6f5a924","MAP_READ","$6f12acf4fe0b2f8f$export$5854928c832c8909","computePipeline","buffer1","buffer2","uniformBuffer","createBindGroup","getBindGroupLayout","entries","binding","resource","buffer","$4ca97dad8fb5626f$export$160e2ecb0ad6cf93","pipeline","$634d558692add223$var$lastTime","$634d558692add223$var$time","$634d558692add223$export$722fbec263ad908a","data","readBuffer","context","deltaTime","queue","writeBuffer","encoder","createCommandEncoder","computePass","beginComputePass","setPipeline","setBindGroup","bindGroup","dispatchWorkgroups","ceil","end","copyBufferToBuffer","submit","finish","mapAsync","GPUMapMode","READ","unmap","encoderRender","textureView","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","clearValue","r","g","b","a","loadOp","storeOp","bindGroupRender","draw","window","requestAnimationFrame","$205b16af4c42845f$var$init","navigator","gpu","alert","canvas","document","querySelector","getContext","adapter","requestAdapter","requestDevice","getPreferredCanvasFormat","configure","alphaMode","workBufferA","workBufferB"],"version":3,"file":"index.5e55d995.js.map"}